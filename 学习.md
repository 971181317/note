# 学习记录

## JVM

参考：https://blog.csdn.net/qq_46153765/article/details/113092445

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210124162416689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUzNzY1,size_16,color_FFFFFF,t_70#pic_center)

### 1. 概述

#### 1.1 主要功能

* 通过ClassLoader寻找和转配class文件
* 解释字节码成为指令并运行，提供class文件的运行环境
* 进行运行期间的内存分配和垃圾回收
* 提供和硬件交互的平台

#### 1.2 class文件

Class文件是JVM的输入，Java虚拟机规范中定义了Class文件的结构

* Class文件是一组以8字节为单位的字节流，各个数据项目按序紧凑排列
* 对于占用空间大于8字节的数据项，按照高位在前的方式分割成多个8字节进行存储
* Class文件格式里面只有两种类型：无符号数、表
  * 无符号数：基本数据类型，以u1、u2、u4、u8来代表几个字节的无符号数
  * 表：由多个无符号和其他表构成的符合数据类型，通常以 "_info"结尾
* class文件的格式
  * javap工具生成非正式的 ”虚拟机汇编语言“
  * 是指令操作码在数组中的下标，该数组以字节形式来存储当前方法的Java虚拟机代码；也可以是相当于方法起始处的字节偏移量
  * 是指令的助记码、是操作数、是行尾的注释

#### 1.3 ASM

ASM是一个Java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能

ASM可以直接产生二进制class文件，也可以在类被加载入虚拟机之前动态改变类行为，ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能根据要求生成新类

目前许多框架如 cglib、Hibernate、spring 都直接或间接地使用ASM操作字节码

> ASM编程模型

* Core API：提供了基于事件形式的编程模型。该模型不需要一次性将整个类的结构读取到内存中，因此这种方式更快，需要的内存更少，但这种编程方式难度较大
* Tree API：提供了基于树型的编程模型。该模型需要一次性将一个类的完整结构全部读取到内存中，所以这种方法需要更多的内存，这种编程方式较简单

### 2. 类加载连接和初始化

#### 2.1 类加载和类加载器

![img](https://img-blog.csdnimg.cn/20210124162632767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUzNzY1,size_16,color_FFFFFF,t_70#pic_center)

* 加载：查找并加载文件的二进制数据
* 连接：将读入内存的类的数据合并到jvm运行环境中
  * 验证：确保类的正确性
  * 准备：为类的静态变量分配内存，并初始化
  * 解析：把常量池中的负号引用转换成为直接引用
* 初始化：为类的静态变量赋值

> 类加载完成的功能

- 通过类的全限定名来获取该类的二进制字节流
- 把二进制字节流转化为方法区的运行时数据结构
- 在堆上创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口

> 加载类的方式

- 最常见的方式：本地文件系统中加载、从jar等归档文件中加载
- 动态的方式：将 java 源文件动态编译成 class
- 其他方式：网络下载、从专有数据库中加载等等

> 类加载器

* Java 虚拟机自带的加载器包括以下几种：
  * 启动类加载器（BootstrapClassLoader）
  * 平台类加载器（PlatformClassLoader） JDK8：扩展类加载器（ExtensionClassLoader）
  * 应用程序类加载器（AppClassLoader）
* 用户自定义的加载器：是 java.lang.ClassLoader 的子类，用户可以定制类的加载方式；只不过自定义类加载器其加载的顺序是在所有系统类加载器的最后

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210124162714796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUzNzY1,size_16,color_FFFFFF,t_70#pic_center)

> 类加载器说明

* 启动类加载器：用于加载启动的基础模块类，比如：java.base、java.management、java.xml等
* 平台类加载器：用于加载一些平台相关的模块，比如：java.scripting、java.compiler *、java.corba *等
* 应用程序类加载器：用于加载应用级别的模块，比如：jak.compiler、jdk.jartool、jdk.jshell 等等；还加载 classpath 路径中的所有类库
* JDK8：启动类加载器：负责将<JAVA_HOME>/lib，或者 -Xbootclasspath 参数指定的路径中的，且是虚拟机识别的类库加载到内存中（按照名字识别，比如 rt.jar，对于不能识别的文件不予装载）
* JDK8：扩展类加载器：负责加载 <JRE_HOME>/lib/ext，或者 java.ext.dirs 系统变量所指定路径中的所有类库
* JDK8：应用程序类加载器：负责加载 classpath 路径中的所有类库Java 程序不能直接引用启动类加载器，直接设置 classLoader 为 null，默认就使用启动类加载器
* 类加载器并不需要等到某个类“首次主动使用”的时候才加载它，JVM规范允许类加载器在预料到某个类将要被使用的时候就预先加载它
* 如果在加载的时候 .class 文件缺失，会在该类首次主动使用时报告 LinkageError 错误，如果一直没有被使用，就不会报错

#### 2.2 双亲委派模型

* JVM中的 ClassLoader 通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器。这里的父子关系是组合而不是继承
  1. 一个类加载器接收到类加载请求后，首先搜索它的内建加载器定义的所有“具名模块”
  2. 如果找到了合适的模块定义，将会使用该加载器来加载
  3. 如果 class 没有在这些加载器定义的具名模块中找到，那么将委托给父级加载器，直到启动类加载器
  4. 如果父级加载器反馈它不能完成加载请求，比如在它的搜索路径下找不到这个类，那子类加载器才自己来加载
  5. 在类路径下找到的类将成为这些加载器的无名模块
* 双亲委派模型对于保证 Java 程序的稳定运作很重要，可以避免一个类被加载多次
* 实现双亲委派的代码在 java.lang.ClassLoader 的 loadClass() 方法中，如果自定义类加载器的话，推荐覆盖实现 findClass() 方法
* 如果有一个类加载器能加载某个类，称为 定义类加载器，所有能成功返回该类的 Class 的类加载器 都被称为初始类加载器
* 如果没有指定父加载器，默认就是启动类加载器
* 每个类加载器都有自己的命名空间，命名空间由该类加载器及其所有父加载器所加载的类构成，不同的命名空间，可以出现类的全路径名 相同的情况
* 运行时包由同一个类加载器的类构成，决定两个类是否属于同一个运行时包，不仅要看全路径名是否一样，还要看定义类加载器是否相同。只有属于同一个运行时包的类才能实现相互包内可见

> 双亲委派模型的问题

* 双亲委派模型有一个问题：父加载器无法向下识别子加载器加载的资源
  * 为了解决这个问题，引入了线程上下文类加载器，可以通过 Thread 的 setContextClassLoader() 进行设置

#### 2.3 类的主动初始化和卸载

Java 程序对类的使用方式分成：主动使用和被动使用

JVM 必须在每个类或接口 ”首次主动使用“ 时才初始化它们；被动使用类不会导致类的初始化

> 主动使用情况：

1. 创建类实例
2. 访问某个类或接口的静态变量
3. 调用类的静态方法
4. 反射某个类
5. 初始化某个类的子类，而父类还没有初始化
6. JVM 启动的时候运行的主类
7. 定义了 default 方法的接口，当接口实现类初始化时

> 类的卸载

当代表一个类的 Class 对象不再被引用，那么 Class 对象的生命周期就结束了，对应的在方法区中的数据也会被卸载

JVM 自带的类加载器装载的类，是不会卸载的，由用户自定义的类加载器的加载的类是可以卸载的

## MySQL

### 语句

1. DDL

   ```sql
   create table [if not exists] `表名`(
       '字段名1' 列类型 [属性][索引][注释],
       '字段名2' 列类型 [属性][索引][注释],
       #...
       '字段名n' 列类型 [属性][索引][注释]
   )[表类型][表字符集][注释];
   
   --修改表名 :
   ALTER TABLE 旧表名 RENAME AS 新表名
   
   --添加字段 : 
   ALTER TABLE 表名 ADD字段名 列属性[属性]
   
   --修改字段 :
   ALTER TABLE 表名 MODIFY 字段名 列类型[属性]
   ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]
   
   --删除字段
   ALTER TABLE 表名 DROP 字段名
   
   --删除数据表
   DROP TABLE [IF EXISTS] 表名
   ```

   > 字段属性

   * UnSigned：无符号的，不能为负值

   * ZEROFILL：0填充的，不足位数的用0来填充 , 如int(3),5则为005
   * Auto_InCrement：自动增长的 , 默认1，当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表
   * NULL 和 NOT NULL：空与非空
   * DEFAULT：默认值

   ```sql
   -- 目标 : 创建一个school数据库
   -- 创建学生表(列,字段)
   -- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email
   -- 创建表之前 , 一定要先选择数据库
    
   CREATE TABLE IF NOT EXISTS `student` (
     `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号',
     `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',
     `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码',
     `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别',
     `birthday` datetime DEFAULT NULL COMMENT '生日',
     `address` varchar(100) DEFAULT NULL COMMENT '地址',
     `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
     PRIMARY KEY (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8
    
   -- 查看数据库的定义
   SHOW CREATE DATABASE school;
   -- 查看数据表的定义
   SHOW CREATE TABLE student;
   -- 显示表结构
   DESC student;  
   -- 设置严格检查模式(不能容错了)
   SET sql_mode='STRICT_TRANS_TABLES';
   ```

   

2. `DML`

   ```sql
   INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3')
   UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition];
   DELETE FROM 表名 [WHERE condition
   --用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;
   TRUNCATE [TABLE] table_name;
   ```

   > TRUNCATE和DELETE区别

   * 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快
   * 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器
   * 使用TRUNCATE TABLE不会对事务有影响 

3. `DQL`

   ```sql
   SELECT [ALL | DISTINCT]
   {* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}
   FROM table_name [as table_alias]
       [left | right | inner join table_name2]  -- 联合查询
       [WHERE ...]  -- 指定结果需满足的条件
       [GROUP BY ...]  -- 指定结果按照哪几个字段来分组
       [HAVING]  -- 过滤分组的记录必须满足的次要条件
       [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序
       [LIMIT {[offset,]row_count | row_countOFFSET offset}]; --  指定查询的记录从哪条至哪条
   ```

   * 排序

     * ASC升序
     * DESC降序

     ```sql
     SELECT s.studentno,studentname,subjectname,StudentResult
     FROM student s
     INNER JOIN result r
     ON r.studentno = s.studentno
     INNER JOIN `subject` sub
     ON r.subjectno = sub.subjectno
     WHERE subjectname='数据库结构-1'
     ```

   * 分页

     ```sql
     /*============== 分页 ================
     语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
     好处 : (用户体验,网络传输,查询压力)
     推导:
         第一页 : limit 0,5
         第二页 : limit 5,5
         第三页 : limit 10,5
         ......
         第N页 : limit (pageNo-1)*pageSzie,pageSzie
         [pageNo:页码,pageSize:单页面显示条数]
         
     */
      
     -- 每页显示5条数据
     SELECT s.studentno,studentname,subjectname,StudentResult
     FROM student s
     INNER JOIN result r
     ON r.studentno = s.studentno
     INNER JOIN `subject` sub
     ON r.subjectno = sub.subjectno
     WHERE subjectname='数据库结构-1'
     ORDER BY StudentResult DESC , studentno
     LIMIT 0,5
     ```

   * 聚合

     | 函数名称 | 描述                                                         |
     | -------- | ------------------------------------------------------------ |
     | COUNT()  | 返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】 |
     | SUN()    | 返回数字字段或表达式列作统计，返回一列的总和。               |
     | AVG()    | 通常为数值字段或表达列作统计，返回一列的平均值               |
     | MAX()    | 可以为数值字段，字符字段或表达式列作统计，返回最大的值。     |
     | MIN()    | 可以为数值字段，字符字段或表达式列作统计，返回最小的值。     |

### 事务

1. ACID

   * 原子性(Atomic)：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。

   * 一致性(Consist)：一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。

   * 隔离性(Isolated)：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。

   * 持久性(Durable)在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

     

### MyISAM和InnoDB

1. 基本区别

   |            | MyISAM      | InnoDB        |
   | ---------- | ----------- | ------------- |
   | 事务支持   | 不支持      | 支持          |
   | 数据行锁   | 不支持 表锁 | 支持 行锁     |
   | 外键约束   | 不支持      | 支持          |
   | 全文索引   | 支持        | 不支持        |
   | 表空间大小 | 较小        | 较大，约为2倍 |

   * `MyISAM`：节约空间，速度较快
   * `InnoDB`：安全性高，事务处理，多表多用户

   数据库本质还是文件存储

2. `MySQL`引擎在物理文件上的区别

   * 表文件
     * \* . frm -- 表结构定义文件
     * \* . MYD -- 数据文件 ( data )
     * \* . MYI -- 索引文件 ( index )

   * `InnoDB` 在数据库表中只有一个.frm文件，, 以及上一级目录的ibdata1文件
   * `MyISAM `类型数据表对应三个文件 



