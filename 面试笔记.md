#  面试笔记

## HashMap

### HashMap的底层数据结构

底层：数组

对key计算出来一个hash值，然后对hash值取模，会定位到数组里的一个元素中去

### jdk1.8对于hash算法和寻址的优化

1. 求hash值

   `h = key.hashCode() ^ (h >>> 16)`

   将hashcode值和自己右移16位取异或，然后转换为int 值得到hash值

``` 
1111 1111 1111 1111 1111 1010 0111 1100（hashcode值）
0000 0000 0000 0000 1111 1111 1111 1111（右移16位）
1111 1111 1111 1111 0000 0101 1000 0011（最后的hash值）
```

   * hash算法的优化︰对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置

2. 寻址算法

   `(n - 1) & hash` -> 数组里的一个位置

   `(n - 1) & hash` -> 效果和hash对n取模一样，但运算性能比hash对n取模要高

```
1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）
0000 0000 0000 0000 0000 0000 0000 1111
1111 1111 1111 1111 0000 0101 1000 0011（经过优化和二进制位运算的新hash值）
```

   hash值&运算取出数组的索引实际上就是低16位进行运算

   当hashcode充当hash值时，重复索引较多

   优化后的hash值，低16位有高16位和低16位的特征，所以与运算出现重复索引较少

   假设两个老hash值低16位相同，求出来的索引值是相同的，但优化过的hash值计算就会不同

   * 寻址算法的优化∶用与运算替代取模,提升性能

### hash冲突

hash冲突问题，链表加红黑树，O(n)和O(logn)

算出key 的 hash 值，到数组中寻址，找到一个位置，把 key-value对放进数组，或者从数组里取出来
**hash碰撞, hash冲突**：两个key，多个key，他们算出来的hash的值，与n-1，与运算之后，发现定位出来的数组的位置还是一样的

相同元素会挂在索引位置的链表中，让多个元素在一个索引里

get找元素发现是个链表，然后遍历链表找key-value对

优化：当链表达到一定长度厚，会吧链表转为红黑树

遍历一颗红黑树找元素o(logn)

### HashMap扩容

2倍扩容

当数组满了的时候，会自动进行扩容，编程一个更大的数组，将原来数组的元素与新数组的长度与运算，重新存放元素

### 红黑树

1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点（NIL节点）。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

### hashmap和hashtable的区别

- Hashtable继承自`Dictionary`类，而HashMap继承自`AbstractMap`类。但二者`都实现了Map接口`。
- Hashtable是线程安全的，HashMap是**非**线程安全的。
- Hashtable保留了`contains()`，`containsValue()`和`containsKey()`三个方法，其中`contains()`和`containsValue()`功能相同。
  HashMap把Hashtable的`contains()`方法去掉了，改成`containsValue()`和`containsKey()`，因为`contains()`方法容易让人引起误解。
- Hashtable既**不**支持Null key**也不**支持Null value；HashMap支持**null作为键**，这样的键只有一个，同时，它还支持可以有一个或多个键所对应的**值为null**。

## 并发编程

### synchronized

加锁，一般来说多事对一个对象进行加锁

  每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor,如果要对这个对象加锁,那么必须获取这个对象关联的monitor的 lock锁
  他里面的原理和思路大概是这样的, monitor里面有一个计数器，从О开始的。如果一个线程要获取monitor的锁,就看看他的计数器是不是0,如果是0的话,那么说明没人获取锁，他就可以获取锁了，然后对计数器加1

使用synchronized加锁，也就是对monitor加锁

加锁指令：monitorenter和monitorexit

如果在加锁的代码段里又对相同对象加锁，锁再加1

运行完锁减1

### CAS

compare and sawp 先比较再复制

使用cas相关的对象，可以不使用synchronized

cas在硬件层面上保证原子性

例：

对int i = 0；进行累加

使用AtomicInteger对象

线程1：首先读取一个值0，，尝试设置1

线程2：首先读取一个值0，，尝试设置1

线程1：cas，获取值0，与旧值相同，设置1

线程2：cas，获取值1，与旧值不相同

线程2：重新读取当前值1，尝试设置2，cas，获取值1，与旧值相同，设置2

### ConcurrentHashMap

JDK 1.8之前，多个数组，分段加锁，一个数组一个锁

JDK 1.8以后，优化细粒度，一个数组，每个元素进行CAS，如果失败说明有人了，此时synchronized对数组元素加锁，链表+红黑树处理，对数组每个元素加锁

JDK并发包里推出了一个ConcurrentHashMap，他默认实现了线程安全性

JDK1.7及之前版本，分段加锁，拆分了多个数组，每个数组都对应一个锁

JDK1.8以及之后，锁粒度的细化，一个大数组，每个元素put操作，都有一个不同的锁。两个线程对同一个位置put，这个时候采取CAS策略

分段加锁，通过对数组的每个元素执行cas策略，如果是很多线程对数组不同的元素执行put，大家是没有关系的。如果其他线程发现失败，就回基于链表+红黑树来处理，synchronized(数组[index])对数组的元素进行加锁

### AQS

ReentrantLock锁，可以使用lock()和unlock()方法，底层实现AQS

AQS:Abstract Queue Synchronizer抽象队列同步器

里面有一个核心变量state，每个线程cas尝试更新state，更新成功后修改`加锁线程`变量

加锁失败的线程，进入等待队列中

正在运行的线程结束后，将state设置0，`加锁线程`变为null，唤醒等待线程队列头线程

AQS非公平锁，当还没唤醒线程队列的线程时，其他线程cas是成功的

在构造方法里传参数true，变为公平锁，线程加锁是判断队列是否有元素

### 线程池

```java
ExecutorService poll = Executors.newFixedThread(10);
poll.submit(new Callable(){
	public void call(){}
});
```

提交任务，先看一下线程池里的线程数量是否小于corePoolSize，也就是10，如果小于，直接创建一个线程出来执行你的任务,一直循环，知道线程池里的数量达到corePollSize

接着再次提交任务，然后发现线程的数量已经达到corePollSize后，将任务放在队列中，然后执行完的线程就会去争抢任务

fixed，队列，LinkedBlockingQueue，无界阻塞队列

* 核心配置参数

  代表线程池的类是ThreadPollExecutor

  ```java
  return new ThreadPoolExecutor( nThreads,
  							nThreads,
                                 0L,
  							Timeunit.MILLISECONDS,
  							new LinkedBlockingQueue<Runnable>());
  ```

  创建一个线程池就是这样子的, corePoolSize，maximumPoolSize，keepAliveTime，queue,这几个东西，如果你不用fixed之类的线程池，自己完全可以通过这个构造函数就创建自己的线程池

  corePollSize：3

  maximumPoolSize:30

  keepAliveTime:60s

  queue：new ArrayBlockingQueue\<Runnable>(200)

  只要线程数量不超过corePollSize，就一直创建新线程执行任务。当等待队列满了后，并且`corePollSize < maximumPoolSize`时，再次创建创建新线程且总数量小于maximumPoolSize去执行任务。当额外创建的线程在keepAliveTime时间之后没有获取到任务，自动销毁

  如果额外线程都创建完了去处理任务，队列还是满的，此时还有新的任务来怎么办?只能reject掉，他有几种reject策略，可以传入 RejectedExecutionHandlerel

  (1)AbortPolicy (2)DiscardPolicy (3)DiscardOldestPolicy (4)CallerRunsPolicy (5)自定义

  创建线程池考虑：corePollSize的数量，队列类型，最大线程数，拒绝策略，线程释放时间

  一般比较常用：FixedPoolThread 

* 如果在线程池中使用无界阻塞队列会发生什么问题?（面试题︰在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升?）

  内存溢出

* 你知道如果线程池的队列满了之后，会发生什么事情吗?

  你可以无限制的不停的创建额外的线程出来，一台机器上，有几千个线程，甚至是几万个线程，每个线程都有自己的栈内存，占用一定的内存资源，会导致内存资源耗尽，系统也会崩溃掉

  自定义一个reject策略，如果线程池无法执行更多的任务了，此时建议你可以把这个任务信息持久化写入磁盘里去，后台专门启动一个线程，后续等待你的线程池的工作负载降低了,他可以慢慢的从磁盘里读取之前持久化的任务，重新提交到线程池里去执行

* 如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办?

  必然会导致线程池里的积压的任务实际上来说都是会丢失的

  如果说你要提交一个任务到线程池里去，在提交之前，麻烦你先在数据库里插入这个任务的信息，更新他的状态︰未提交、已提交、已完成。提交成功之后，更新他的状态是已提交状态

  系统重启，后台线程去扫描数据库里的未提交和已提交状态的任务，可以把任务的信息读取出来，重新提交到线程池里去，继续进行执行
  
### 多线程死锁产生的原因

1. 互斥等待：有锁(一般无法解决)
2. hold and wait（解决：一次性获取所有资源）
3. 循环等待：线程1先a后b，线程2先b后a，当1获取了a，2获取了b之后，就进入了循环等待（解决：按顺序获取资源）
4. 无法剥夺的等待（解决：加入超时）

## JVM

![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp)

运行时常量池：属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。

### java内存模型

* 原理 

  read：从主内存中读取数据

  load：将读取的数据加载到工作内存（cpu级别的缓存）中

  use：线程使用数据

  assign：将计算的出的值重新设置

  store：将新数据常识往主内存去写

  write：将新数据写到主内存之中

* 特点

  原子性：同一时间只要一个线程可以对当前数据进行操作

  有序性：有时候为了提高代码执行的效率，会将代码进行重排序，有有序性：不会发生代码重排导致代码异常

  可见性：有可见性：其他线程更新完数据，强制其他线程看见更新的新值

### 内存区域

### volatile

* 底层

  是用来解决可见性和有序性的，在有些罕见的条件之下，可以有限的保证原子性

  将变量具有可见性：当变量加上volatile关键字之后，当某个线程对变量进行修改写入主内存中时，其他线程的工作内存中的数据会失效，当其他线程use时发现失效后，会强制重主内存中重新加载值

volatile不保证原子性，保证原子性还得使用synchronized和lock

* 内存屏障

  变量使用volatile之后，在变量读写的时候回加入内存屏障，不能加入指令重排

* lock指令

  对volatile修饰的变量，执行写操作的话jvm会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改

  如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了

### happens-before原则

编译器、指令器可能对代码重排序，乱排，要守一定的规则，happens-before原则，只要符合happens-before的原则，那么就不能胡乱重排，如果不符合这些规则的话，那就可以自己排序

1. 程序次序规则:一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 锁定规则:一个unLock操作先行发生于后面对同一个锁的lock操作
3. volatile变量规则:对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作
4. 传递规则:如果操作A先行发生于操作B，而操作B又先行发生于操作c，则可以得出操作A先行发生于操作c
5. 线程启动规则:Thread对象的start()方法先行发生于此线程的每个一个动作
6. 线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则:线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8. 对象终结规则:一个对象的初始化完成先行发生于他的finalize()方法的开始

规则制定了在一些特殊情况下，不允许编译器、指令器对你写的代码进行指令重排，必须保证你的代码的有序性
但是如果没满足上面的规则，那么就可能会出现指令重排，就这个意思。这8条原则是避免说出现乱七八糟扰乱秩序的指令重排，要求是这几个重要的场景下，比如是按照顺序来，但是8条规则之外，可以随意重排指令。

### 垃圾回收

1. 需要GC的内存区域

   jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。

2. 回收的对象

   1. 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

   1. 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

3. 算法

   * 标记-清除算法：找到不应用的数据清除，会产生内存碎片
   * 标记-压缩算法：找到不应用的数据清除，整理位置，不产生碎片
   * 复制：两块相同的区域，回收的时候把使用的复制到另一边，然后循环往复，不会产生内存碎片
   * 分代：**新生代(Young)和老年代(Tenure)**。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

## java类加载机制

### 时机

- 隐式加载 new 创建类的实例,
- 显式加载：loaderClass,forName等
- 访问类的静态变量，或者为静态变量赋值
- 调用类的静态方法
- 使用反射方式创建某个类或者接口对象的Class对象。
- 初始化某个类的子类
- 直接使用`java.exe`命令来运行某个主类

### 过程

我们编写的`java`文件都是保存着业务逻辑代码。`java`编译器将 `.java` 文件编译成扩展名为 `.class` 的文件。.class 文件中保存着java转换后，虚拟机将要执行的指令。当需要某个类的时候，java虚拟机会加载 .class 文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载。

* 双亲委派

  双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用组合关系来复用父类加载器的相关代码。

  如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果父类能够完成类的加载任务，就会成功返回，倘若父类加载器无法完成任务，子类加载器才会尝试自己去加载，这就是双亲委派模式。就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。

* 对象创建过程

  当虚拟机遇到一个`new`的指令的时候，首先去检查这个指令是否能在`常量池`中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有则执行相应初始化的过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存，`对象所需要的内存的大小在类加载完成后便可以完成确定`。`内存分配完成以后，虚拟机需要将分配的内存空间都初始化为零值`，保证了对象的实例字段在Java代码中可以不赋予初值就直接使用，程序能访问到这些字段的数据类型对应的零值。再接下来对象需要进行必要的设置，这个对象是哪个类的实例，如何才能找到这个类的元数据信息，如何找到对象的哈希码，对象的GC分带年龄。

## 网络

### TCP/IP四层模型

4层:数据链路层（以太网协议)，网络层（ip协议)，传输层〈tcp协议)，应用层（http协议)

数据链路层：通过数据包传输数据，然后校验

网络层：会将数据发送至路由，然后通过多个路由找到最后接收的人，通过ip协议来确定终点

传输层：检验包是否可靠，如果不可靠，有重传机制。tcp协议基于连接，会建立一个可靠的连接来传输数据

应用层：找到数据所服务的应用，http/ftp/email 协议

### 不可靠的原因

1. 丢包，重复包
2. 出错（重传解决）
3. 乱序：收到的数据顺序不对
4. 安全问题：中间人攻击，窃取，篡改

### TCP三次握手，四次握手

![三次握手](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

![四次挥手](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

### TCP可靠传输的实现

1. 停止等待协议：每发送完一个分组就停止发送，等待对方的确认，收到确认后再发送下一个分组。

2. 超时重传（ARQ）：如果超时没有收到，则重新发送，如果是延时收到接受方的反馈则说明也不做

3. 流水线传输：连续发送多个分组

   * 发送：连续发，如果超时没收到回应，则重新从从超时位置重发

   * 接收：按序接收，接收到有差错的分组，让发送端超时

4. 滑动窗口协议

   tcp协议中使用，维持发送方/接受方缓冲区

   ![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31.png)

   正常情况下，始终维持了一个长度确定的窗口，里面放着已发送未接收到ack（服务器确认收到回复的）和待发送的数据，例如：当收到4号包的ack时，窗口右移，然后添加11号包，然后在发送新包9

   ![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.png)

   丢失ack：服务器没有收到5号包，或许收到了之后的包，服务器不会发送之后的包ack信息，当客户端超时没有收到ack时，重新发送5号包，这是服务器收到了5号包，假设服务器之前也收到了678号包，这是会把5678的ack都送回去，然后窗口右移继续

### tcp流量控制

链接建立时，B根据自己的接受缓存大小确定窗口值大小，然后告诉A，我的窗口有多大，然后A就根据B给出的窗口值构造自己的发送窗口(发送缓存不一定比接受缓存大)。

* 滑动窗口也可以控制

* 持续计数器

  假设发送方想停止传输，发送0信号，接收端发送了非0信号，然后丢失，会出现死锁

  在收到0信号的时候启动持续计数器，如果在规定时间内没有收到规定的报文，就发送一个探测报文，判断报文是否丢失

### tcp拥塞控制

若网络中有许多资源同时出现供应不足，网络性能就要明显变化，整个网络的吞吐量将随着输入负荷的增大而下降，这就是拥塞。

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。

* 慢开始和拥塞避免

  发送方维持一个拥塞窗口(cwnd)的状态变量。其大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口小于或等于拥塞窗口。

  * 发送方控制拥塞窗口的原则是

    只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些， 以减少注入到网络中的分组数

* 快重传和快恢复

  快重传的算法思路是：

  - 要求接收方每收到一个时序的报文段后就立即发出重复确认，而不是等待发送数据时才进行捎带确认
  - 发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期

  快恢复的算法思路是：

  - 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始阀值ssthresh减半
  - 接着不执行慢开始，而是从新阀值ssthresh开始执行拥塞避免算法(加法增大)

### http

http请求封装到应用层数据包,封装在tcp数据包,封装在ip数据包,封装在以太网数据包,如果过大，可能会拆成几个包，走以太网协议+交换机->广播->网关->多个网关->目标的机器->一层一层拆包->http请求报文->传递给tomcat-> spring mvc -> http响应->—样的路径会去

### http状态码

1. 1xx：服务器就收到客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码

2. 2xx：成功。代表：200

3. 3xx：重定向。

   301(永久性重定向)

   302(临时性重定向)

   303（临时性重定向，表明应该采用get）

   304(访问缓存)

   307(和303相同，307会遵照浏览器标准)

4. 4xx：客户端错误

   400（表示请求报文中存在语法错误）

   403（服务器拒绝访问）

   404(请求路径没有对应资源)

   405(请求方式没有对应的doXxx方法)

5. 5xx：服务器端错误

   500(服务器内部出现异常)

   503（表示服务器暂时处于超负载或正在进行停机维护，无法处理请求）

### http2

1. 二进制分帧

   HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

2. 多路复用

   - 同域名下所有通信都在单个连接上完成。
   - 单个连接可以承载任意数量的双向数据流。
   - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

3. 服务器推送

   服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

4. 头部压缩

   HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。

### 访问www.baidu.com 的过程

1. 要先使用 arp 获取默认网关的 mac 地址
2. 组织数据发送给默认网关(ip 还是 dns 服务器的 ip，但是 mac 地址是默认网关的 mac 地址)
3. 默认网关拥有转发数据的能力，把数据转发给路由器
4. 路由器根据自己的路由协议，来选择一个合适的较快的路径转发数据给目的网关
5. 目的网关(dns 服务器所在的网关)，把数据转发给 dns 服务
6. dns 服务器查询解析出 baidu.com 对应的 ip 地址，并原路返回请求这个域名的 client 得到了 baidu.com 对应的 ip 地址之后，会发送 tcp 的 3 次握手，进行连接
7. 使用 http 协议发送请求数据给 web 服务器
8. web 服务器收到数据请求之后，通过查询自己的服务器得到相应的结果，原路返回给浏览器
9. 浏览器接收到数据之后通过浏览器自己的渲染功能来显示这个网页
10. 浏览器关闭 tcp 连接，即 4 次挥手结束，完成整个访问过程

### tcp一方宕机

使用心跳包检测

### 输入一个URL，但是没有访问到预期的网站，是什么原因？

1. DNS坏掉了，修改自己的IP地址为8.8.8.8试试
2. 网络断了
3. 服务器拒绝访问
4. 请求或者响应在网络传输中途被劫走了

## mysql

### 引擎

innodb（常用），myisam（用的很少了）

* myisam

  不支持事务，不支持外键约束，索引文件和数据文件分开，内存了可以缓存跟多的索引，对查询性能更好，适用于少量插入大量查询的场景

* innodb

  mysql5.5之后默认的储存引擎。支持事务，支持外键约束，高并发，大数据量，高可

### 索引

b-树：左节点比右节点小，两节点之间有指针指向两节点范围之间的子树，每个节点储存data或data指针

b+树：在b-树基础上，只有叶子节点储存数据，两节点之间的子树包含左节点

mysql 优化b+树：在叶子节点加上数据访问指针，比如id>18，找到18，然后向后遍历

* m阶B/B+树
  1. 每个 非叶子节点（除根外）至多有m个儿子，至少有[m/2]个儿子
  2. 根节点（如果不是叶子）至少有两个儿子
  3. 所有叶子节点都在同一层

* myisam

  索引文件和数据文件分开，找到数据行物理地址，数据文件单独放一个文件

* innodb

  要求必须有主键，可以默认根据主键建立一个索引，叫做聚簇索引

  数据文件本身同时也是索引文件

  主键索引：聚簇索引

  如果对非主键字段创建索引，叶子节点里储存的就是主键，然后再根据数据文件的聚簇索引查询数据行

  不要用超长的uuid最为作为主键，，最终会导致索引变得过大

  建议一般用auto_increment自增作为主键值，因为这样保证聚簇索引直接加记录，不是单调递增的主键可能会导致b+树分裂后重新组织

* 索引类型

  1. 普通索引：这是最基本的索引，它没有任何限制
  2. 唯一索引：与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须是唯一的，创建方法和普通索引类似。
  3. 组合索引：创建title和time的索引，相当于创建了：-title，time和-title两组组合索引（满足最左前缀）

* 索引作用

  1. 加快查找速度
  2. 约束数据的值

* Query Plan

  在select语句前加入explain关键字，可以查看sql语句的执行计划，例如：是否使用索引，或者使用了那些索引

* 索引的使用规则

* 缺点和使用注意

  尽量使用较少的索引
  
* 覆盖索引：如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

* 索引失效的情况

  1. like 以%开头，索引无效
  2. or语句前后没有同时使用索引
  3. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
  4. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
  5. 对于多列索引，不是使用的第一部分，则不会使用索引
  
* 验证

### 事务

* acid 

  1. 原子性：是不可分割的最小操作单位，要么同事成功，要么同时是失败
  2. 持久性：如果事务一旦提交和回滚后，数据库会持久化的保存数据
  3. 隔离性：多个事务，相互独立
  4. 一致性：事务操作前后，数据总量不变

* 隔离级别

  脏读：一个事物，读取到另一个事务中没有提交的数据
  不可重复读(虚读)：在同一个事务中，两次读取到得数据不一样
  幻读：一个事物操作(DML)数据表所有记录,另一个事物添加一条数据，则第一个事务查询不到自己的修改

  1. read uncommitted：读未提交
     * 产生的问题：脏读，不可重复读，幻读
  2. read committed：读已提交(Oracle默认)
     * 产生的问题：不可重复读，幻读 
  3. repeatable read：可重复读(MySQL默认)
     * 产生的问题：幻读 
  4. serializable：串行化
     * 可以解决所有问题

* mysql默认可重复读，mysql通过mvcc来实现

  innodb，会在每行数据的最后加两个隐藏列，一个保存行创建时间，一个保存行的删除时间，但保存的不是时间，而是事务id，事务id是mysql自己维护递增的，全局唯一

  查到的数据只能是创建id小于自己，删除id大于自己元素

  如果并发修改，则会创建多行快照，也就是多条相同id数据

### 数据库锁

分为表锁，页锁，行锁

* myisam

  一般会加表锁，执行查询的时候，会默认家表共享锁，也就是表读锁，其他人只能查，不能写。然后在写的时候，会加表独占锁，也就是写锁，别人不能读也不能写

* innodb

  行锁有共享锁(S)和排他锁(X)。

  共享锁：多个事务都可以加共享锁读同一行数据，但是别的事务不能写这行数据

  排他锁：一个事务可以写这行数据，别的事务只能读不能写

  insert，update，delete，innodb会自动给那一行加行级排他锁

  select，innodb什么也不加，mysql默认实现了可重复读，实现了mvcc机制，一般不会有冲突，大家自己读取自己快照就可以了

  表锁有意向共享锁，就是说家共享行锁的时候，必须先加这个共享表锁；意向排他锁，给某行加排他锁时，必须先给表加意向排他锁。表锁是innodb自动添加

  还可以手动加锁

* 悲观锁和乐观锁

  悲观锁：给单条数据加锁，然后等待修改完成后释放锁，例如for update

  乐观锁：先读取数值，判断版本号是否相同，如果不同重新读取

* 解决幻读

  使用间隙锁，当间隙加锁后，无法在间隙插入

### sql注入

获取表结构就可以注入，比如开源项目，将错误信息外显，不使用预编译sql

### 大表优化

1. 限定数据范围：限定查询的范围
2. 读写分离：主库负责写，从库负责读
3. 缓存
4. 垂直分区：拆表
5. 水平分区：按片储存，达到分布式的目的
6. 优化索引
7. 优化硬件

### 查询优化

1. 储存引擎
2. 分库分表
3. 避免全表扫描，建立索引
4. 避免使用or
5. where避免使用`!=`，`<>`操作符，null值判断
6. update只更改1，2字段不要使用全部字段
7. 先分页再join
8. 减少算数运算
9. 符合索引最左
10. 使用varchar

### sql语句

* 聚合函数的使用
  `AVG()`：计算平均值
  `MIN()`：计算最小值
  `MAX()`：计算最大值
  `SUM()`：计算该列所有值的和
  `COUNT()`：计算结果集行数

```sql
INSERT INTO Student VALUES ('2017220302029','LiJiaxin','1999-07-08','软件工程');
UPDATE Student SET BirthDay='1999-02-15' WHERE StudentName='YuanYuan';
DELETE FROM Student WHERE StudentName='YuanYuan';

SELECT Major AS 专业, COUNT(StudentID) AS 学生人数
FROM Student
WHERE StudentGender='女'  --过滤数据集：性别为女
GROUP BY Major  --根据专业来分组
HAVING COUNT(*)>3;  --限定分组数据：行数大于3的
limit 开始的索引，每页查询的条数
```

## Spring

* spring ioc

  * IOC（Inverse of Control）：控制反转，它不是什么技术，而是一种设计思想。在Java开发中，IoC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
  * DI（Dependency Injection）：依赖注入，用一个单独的对象（装配器）来装配对象之间的依赖关系 。

  spring容器，根据xml配置，或者是你的注解，去实例化你的一些bean对象,然后根据xml配置或者注解，去对 bean对象之间的引用关系，去进行依赖注入，某个bean依赖了另外一个bean

  底层的核心技术,反射,他会通过反射的技术,直接根据你的类去自己构建对应的对象出来，  用的就是反射技术

  spring ioc，系统的类与类之间彻底的解耦合

  ![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/spring%20ioc.png)

* spring aop

  aop：面向切面编程

  spring在运行的时候，会使用动态代理技术

  aop核心技术就是动态代理

  当好多类有相同的一些代码时，可以定义一个切面，切面中定义切面前，后，正常返回，抛出异常等位置的代码，然后执行时在切面产生的位置执行定义的切面中的代码

  spring运行时，动态代理，织入相同代码

## 操作系统

### 进程与线程

1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2. 线程的划分尺度小于进程，使得多线程程序的并发性高。
3. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E8%BF%9B%E7%A8%8B.png)

![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/%E7%BA%BF%E7%A8%8B.png)

PC:存放下一条指令的地址

进程中的内存大小与物理内存无关，与系统的位数有关

### 进程间通信有哪些方式？它们的区别？

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在有血缘关系的进程间使用，进程的血缘关系通常是指父子进程关系。

2. 命名管道（named pipe）：也是半双工的通信方式，但是它允许无亲缘关系关系进程间通信。

3. 信号（signal）：是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。

4. 信号量（semophere）：信号量是一个计数器，可用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，**主要作为进程间以及同一进程内不同线程之间的同步手段**。

5. 消息队列（message queue）:消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递消息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

6. 共享内存（shared memory）:就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，**共享内存是最快的IPC方式**，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量等配合使用，来实现进程间的同步和通信。
7. 套接字（socket）：套接口也是进程间的通信机制，与其他通信机制不同的是它可用于不同及其间的进程通信。
* 几种方式的比较：
  管道：速度慢、容量有限
  消息队列：容量收到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
  信号量：不能传递复杂信息，只能用来同步。
  共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。

### 常用进程间通信

1. 文件用来通信
2. Signal：信号，发送信号，让其他进程来进行一些操作
3. 消息队列
4. 管道和命名管道
5. 共享内存
6. 同步机制，如信号量
7. Socket（套接字）：可以用于不同机器之间的通信

### 线程间的通信机制

1. 锁机制：互斥锁、条件变量、读写锁
   互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   条件变量可以以原子的方式进行阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。**条件变量始终与互斥锁一起使用**。
2. 信号量机制：包括无名信号量和命名线程信号量
3. 信号机制：类似进程间的信号处理

### 进程的调度算法

1. 先来先服务（FCFS）:此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序选择作业（或进程）
2. 短作业优先（SJF:Shortest Process First）：这种算法主要用于作业调度，它从作业后备序列中挑选所需运行时间最短的作业进入主存运行。
　　3. 时间片轮转调度算法：当某个进程执行的时间片用完时，调度程序便终止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证队列中的所有进程，在已给定的时间内，均能获得一时间片处理机执行时间。
　　4. 高响应比优先：按照高响应比（已等待时间+要求运行时间）/要求运行时间 优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP。选择最大的作业投入运行。
　　5. 优先权调度算法：按照进程的优先权大小来调度。使高优先权进程得到优先处理的调度策略称为优先权调度算法。注意：优先数越多，优先权越小。
　　6. 多级队列调度算法：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个队列，所有的作业（进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。

### 僵尸进程

子进程结束了，父进程没有对其进行回收，这时它就是僵尸进程。

* 避免
  1. 在父进程中使用`wait()`和`waitpid()`等函数等待子进程结束，当收到子进程发来的信号`SIGCHLD`时就会调用方法，但这会导致父进程挂起；
  2. 如果父进程不关心子进程什么时候结束，即 忽略信号`SIGCHLD`，那么可以使用`signal(SIGCHLD,SIG_IGN)`通知内核，`SIG_IGN`表示忽略，内核收到后会对该子进程进行回收，并且不会再给父进程发送信号；
  3. 还有一些技巧，就是`fork()`两次，父进程`fork()`一个子进程后继续工作，子进程`fork()`一个孙进程后退出，那么此时孙进程就会被`init`接管，孙进程结束后会被`init`回收，但是子进程的回收还是需要父进程来做。

### 死锁

* 原因：竞争资源，进程间顺序不当
* 必要条件
  1. **互斥**条件 ：进程对分配到的资源进行排它性使用。
  2. **请求和保持**条件 ：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，请求进程阻塞，但对已经获得的资源不释放。
  3. **不剥夺**条件 ：进程已获得的资源，使用完之前不能被剥夺，只能用完自己释放。
  4. **环路等待**条件 ：发生死锁时，必然存在进程—资源的环形链。
* 银行家算法——避免死锁
  1. 当前状态下，某进程申请资源；
  2. 系统假设将资源分给该进程，满足它的需求；
  3. 检查分配后的系统状态是否是安全的，如果是安全，就确认本次分配；如果系统是不安全的，就取消本次分配并阻塞该进程。（第三步又称**安全算法**）

### 寻址空间

硬盘->内存->缓存->寄存器  由慢到快

32位->4G

64位->~10^19Bytes

* 寻址过程:变量指向的是逻辑内存（2^32或2^64大小，进程之间是独立的），然后逻辑内存找到物理内存里的数据，找不到的话数据就会在虚拟内存里。然后从虚拟内存找到包含p的分页，然后将数据放进物理内存中，如果放不下就把物理内存中不常用的数据替换，最后找到数据放入寄存器中

### 存储管理

为了能将用户程序装入内存，必须为它分配一定大小的内存空间。存储器分配方式有`连续分配`存储管理方式和`离散分配`存储管理方式两种。

* 分页储存管理方式

  在该方式中，将`用户程序的地址空间`分为若干个固定大小的区域，称为“`页`”或“页面”。典型的页面大小为 1KB，相应地，也将`内存空间`分为若干个`物理块`或页框，页和块的大小相同。这样可将用户程序的任一页放入任一物理块中，实现了离散分配。

  1. `页表`：每个进程对应 1 个页表，描述该进程的各页面在内存中对应的`物理块号`。
  2. `作业表`：整个系统 1 张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息。
  3. `空闲块表`：整个系统 1 张，记录主存当前空闲块。

* 分段储存管理方式

  在该方式中，将用户程序的地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。

  一个用户作业常是由多个不同功能的模块组成（如代码段、数据段、共享段）。

  可以把`每个功能模块`做为一个`“段”`，有自己的段名和长度。每段从0开始进行编址。在存储器分配时，以段为单位，这些段在内存中可以不相邻链接，（`段内的地址空间是连续的`），所以也同样实现了离散分配。

* 段页式储存管理方式（上面两种结合）

  先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。

### 页面置换算法

**最佳置换算法（OPT）**

从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择`最长时间不需要访问`的页面。

**先进先出置换算法（FIFO）**

总是选择作业中`驻留时间最长`(即最老)的一页淘汰。即：先进入主存的页面先退出主存 。

**最近未使用（LRU）置换算法**

利用局部性原理，根据一个作业在执行过程中过去的页面访问踪迹来`推测未来的行为`。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。

* 当需要置换一页面时，选择在`最近一段时间内最久不用`的页面予以淘汰。

**最近最少使用（LFU）**

选择到当前时间为止被`访问次数最少`的页面被置换。

### 文件

* 顺序储存：不便于动态文件
* 链式储存：寻找时间长
* 索引储存：需要额外的空间
* 散列储存

## 设计模式

* 单例模式

  1. 单例类只能有一个实例。
  2. 单例类必须自己创建自己的唯一实例。
  3. 单例类必须给所有其他对象提供这一实例。

* 状态（状态模式）模式

  比如实现继承关系时，工程师和管理者的关系，当角色发生改变时，相对应方法的实现就会改变，这时设计接口Role，分别对两个岗位的职能进行实现，然后工程师和管理者取消继承关系，然后都包含Role对象确定职能，然后两者执行相同方法时调用对应role接口的方法即可。方便了角色的变化

## 外部排序

* 归并排序 

  k路归并，用堆（优先队列）来实现，每次从k个元素选数据时间太麻烦，有可能从网路或硬盘，所以可以建立一个缓冲区来缓解

## 测试

### 模型

1. 瀑布模型

   必须等前一阶段的工作完成后，才能开始后一阶段的工作

   前一阶段的输出文档就是后一阶段的输入文档，因此只有前一阶段的输出文档正确，后一阶段的工作才能获得正确的结果

2. 快速原型模型

   它允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以丰富细化软件需求；开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护

3. 增量模型

   增量模型也称渐增模型。使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能

   使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能

4. 螺旋模型

   螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径

   使用原型及其他方法来尽量降低风险。

### 软件测试种类

![](https://dxytoll-img-1304942391.cos.ap-nanjing.myqcloud.com/img/QQ%E6%88%AA%E5%9B%BE20201219135038.png)

### 测试方法

1. 黑盒测试：把测试对象当成一个黑盒子，测试人员完全不考虑逻辑结构和内部特性， 只依据程式的需求说明书 来检查程式的功能是否满足它的功能说明。 
   * 黑盒有等价类划分法，边界分析法，因果图法和错误猜测法。
   * 有效等价类：对于规格说明合理的、正确的、有意义的输入数据构成的集合。反之为无效等价类
2. 白盒测试：把测试对象当成一个透明的盒子，允许测试人员利用程序内部逻辑结构及 相关信息，设计或选择测 试用例，对程式所有逻辑路径进行测试。 
   * 白盒有逻辑覆盖法，循环测试路径选择，基本路径测试。
   * 用例设计：语句覆盖,分支覆盖,条件覆盖,路径覆盖,分支条件覆盖,**覆盖率最高的是路径覆盖**

1. 单元测试：白盒测试的一种，对软件设计中的单元模块进行测试。 
2. 集成测试：在单元测试的基础上，对单元模块之间的连接和组装进行测试。 
3. 系统测试：在所有都考虑的情况下，对系统进行测试。 
4. 验收测试：第三方进行的确认软件满足需求的测试。

### 测试用例

#### 购物车

1.界面测试

- 打开淘宝购物车页面后，页面的布局是否合理，是否完整。
- 不同卖家的商品在不同的table区域显示，区分明显。
- 页面的功能按钮可以正常显示。
- 商品的最下方显示失效宝贝。
- 页面的最低端显示“你可能喜欢”
- 向下滑动页面，在购物车顶端展示“购物车”。
- 购物车中如果存在有商品降价、库存不足、限购件数等，在商品详情的下面，会有对应的字体展示。

2.基本功能

- 购物车页面的所有连接是否正常。
- 从商品信息页面添加的商品能显示在购物车中。
- 若未登录，点击购物车中的商品直接进行结算，则提示用户输入用户名和密码，或者提示用户进行注册。
- 若没有选择任何商品，点击结算，则提示用户“请添加要结算的商品”。
- 勾选商品后，已选商品的总价（和优惠满减活动）会显示。
- 勾选商品，点击结算按钮后，进去确认订单信息页面。
- 购物车页面中，可以对添加商品信息做信息的修改，并自动保存成功。
- 可以在购物车中重新修改商品规格。
- 购物车能添加的商品种类是有数量上限的。
- 结算的时候商品可以全选，选择底部的全选按钮。
- 可以在购物车页面对宝贝进行管理。

3.性能测试

- 打开购物车时间是否在已定的用户可以棘手的时间范围内。
- 编辑购物车：删除、添加商品需要的时间。
- 在购物车页面选择需要购买的商品进行结算的时候，结算金额可不可以实时显示。
- 清空失效商品需要的时间。

4.兼容性测试

- iOS：不同型号，不同的iOS系统。
- 安卓：不同品牌，不同型号，不同的安卓系统。

5.网络环境

- 3G、4G、WiFi网络环境下应用的各功能可正常运行。
- 网络异常时，数据交换是否会有提醒。
- 中途断网再很快连网，数据是否可以自动恢复，正常加载。
- 只允许内网访问的APP，在连接到外网时是否会有提醒。

6.异常测试

- 没有内存时，APP是否能够正常相应。
- 横竖屏切换展示。
- APP运行时网络中断。
- 反复操作某一个功能，不断点击和刷新，是否出现闪退。
- APP运行时接入电话、短信、社交软件的信息提示时，是否能够正常运行。

#### 微信朋友圈

1. 点赞功能

* 网速对点赞的影响
* 点赞的人个数显示是否正确
* 共同好友能否看到点赞状态
* 能否显示点赞得人的头像和昵称，若能显示是否正确
* 一行显示几个点赞的头像
* 能否正常的点赞和取消点赞
* 点赞显示能否按照时间的先后
* 消息列表中是否显示点赞人的昵称，头像和点赞时间。
* 不同手机操作系统显示界面
* 能否及时刷新
* 点赞后还能不能评论
* 点赞是否有上限

2. 评论功能

* 网速对评论的影响
* 共同好友能否看得到评论，非共同好友能否看到评论状态
* 评论能否按时间先后顺序显示
* 评论能否显示评论人的昵称，若能显示是否正确
* 能否回复评论
* 是否可以既评论又点赞
* 评论和点赞后是怎样现实的，分两次显示，还是一次显示
* 评论是否有上限
* 能否及时刷新
* 未登录情况下能否看得到
* 不同手机如何显示
* 是否能将评论全部显示在朋友圈下面
* 好友能否看到发圈人的评论及回复

3. 界面显示

* 是否是显示发朋友圈的人的昵称、头像、以及具体内容
* 是否按照发朋友圈的时间距离现在远近来排序
* 图片显示是否正确
* 是否显示自己的个人朋友圈背景
* 下拉是否有更新

4. 性能测试

   时间，内存，电量

5. 网络

   2g，3g，4g，5g，wifi，无网，超时

6. 兼容性

   不同机型，不同版本，不同系统

#### 登录

1. 功能测试(Function Test) 
   * 输入正确的账号和密码，点击提交按钮，验证是否能正确登录。（正常输入）
   * 输入错误的账号或者密码, 验证登录会失败，并且提示相应的错误信息。（错误校验）
   * 登录成功后能否跳转到正确的页面（低）
   * 账号和密码，如果太短或者太长，应该怎么处理（安全性，密码太短时是否有提示）
   * 账号和密码，中有特殊字符（比如空格），和其他非英文的情况（是否做了过滤）
   * 记住账号的功能
   * 登录失败后，不能记录密码的功能 
   * 账号和密码前后有空格的处理 
   * 密码是否加密显示（星号圆点等）
   * 牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个 按钮是否好用 
   * 登录页面中的注册、忘记密码，登出用另一帐号登录等链接是否正确
2. 性能
   * 打开登录页面，需要几秒
   * 输入正确的账号和密码后，登录成功跳转到新页面，不超过 5 秒
   * 登录成功后生成的 Cookie 是否有 HttpOnly(降低脚本盗取风险) 
   * 账号和密码是否通过加密的方式，发送给 Web 服务器 
   * 账号和密码的验证，应该是用服务器端验证，而不能单单是在客户端用 javaScript 验证
   * 账号和密码的输入框，应该屏蔽 SQL 注入攻击 
   * 账号和密码的的输入框，应该禁止输入脚本（防止 XSS 攻击）
   * 错误登录的次数限制（防止暴力破解）
   * 考虑是否支持多用户在同一机器上登录；
3. 可用性测试
   * 是否可以全用键盘操作，是否有快捷键 
   * 输入账号，密码后按回车，是否可以登录
   * 输入框是否可以以 Tab 键切换  
4. 兼容性
   * 主流浏览器
   * 不同系统
   * 分辨率  

## Linux

### 常用指令

cd /home 进入 '/ home' 目录' 
cd .. 返回上一级目录 
cd ../.. 返回上两级目录 
cd 进入个人的主目录 
cd ~user1 进入个人的主目录 
cd - 返回上次所在的目录 
pwd 显示工作路径 
ls 查看目录中的文件 
ls -F 查看目录中的文件 
ls -l 显示文件和目录的详细资料 
ls -a 显示隐藏文件 
ls *[0-9]* 显示包含数字的文件名和目录名 
tree 显示文件和目录由根目录开始的树形结构
lstree 显示文件和目录由根目录开始的树形结构
mkdir dir1 创建一个叫做 'dir1' 的目录' 
mkdir dir1 dir2 同时创建两个目录 
mkdir -p /tmp/dir1/dir2 创建一个目录树 
rm -f file1 删除一个叫做 'file1' 的文件' 
rmdir dir1 删除一个叫做 'dir1' 的目录' 
rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 
rm -rf dir1 dir2 同时删除两个目录及它们的内容 
mv dir1 new_dir 重命名/移动 一个目录 
cp file1 file2 复制一个文件 
cp dir/* . 复制一个目录下的所有文件到当前工作目录 
cp -a /tmp/dir1 . 复制一个目录到当前工作目录 
cp -a dir1 dir2 复制一个目录 
cp -r dir1 dir2 复制一个目录及子目录
find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 
find / -user user1 搜索属于用户 'user1' 的文件和目录 
find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 
find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 
find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 
find / -name \*.rpm -exec chmod 755 '{}' \; 搜索以 '.rpm' 结尾的文件并定义其权限 
find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 